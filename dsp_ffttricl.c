/** 20.03.2008 @file
*   TRICL FFT
*   - Orignated by Dan Bernstein (djbfft)
*   - Twiddle gen & simplification by Colin Percival (TRICL)
*   ASP changes:
*   - real-complex (r2c & c2r) transforms and convolutions restored.
*   - 2D transform and convolution helper added
*/
/*-
 * Copyright (c) 2005 Colin Percival
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted providing that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Redistributions of source code must ensure that the list of
 *    copyright notices is complete, and the lack of a copyright notice
 *    corresponding to a copyrightable contribution or modification may
 *    be taken as an affirmative statement that said contribution or
 *    modification has been placed in the public domain.
 * 4. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Colin Percival.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "dsp_ffttricl.h"
#include <math.h>
#include <assert.h>

// for convolution helpers:
#include <stdlib.h>
#include <string.h>

#define UNUSED(x) (void)(x)

/**T
The value {\em TRICL\_ROOTS\_SQRTHALF} is the correctly rounded double 
precision value of $\sqrt{1 / 2}$.  It is approximately $0.435 \cdot 
2^{-53}$ larger than the exact value.
*/
//#define TRICL_ROOTS_SQRTHALF    0x1.6A09E667F3BCDp-1
#define TRICL_ROOTS_SQRTHALF     7.071067811865475244e-0001


/**T
\section{Correctly rounded double-precision constants}

A value $x$ can be converted into a correctly rounded double precision 
floating-point constant via the following MAPLE code:

\begin{verbatimtab}
r := proc(x)
    global Digits;
    local y, sgn, pow, mant;

    if x = 0 then
        RETURN("0.0");
    fi;

    Digits := 30;
    sgn := sign(evalf(x));
    pow := floor(log[2.](x * sgn));
    y := evalf(x * sgn * 2^(52 - pow));

    if abs(y - round(y)) > 0.49999 then
        RETURN("CANNOT ROUND, NEED MORE DIGITS");
    fi;

    if sgn > 0 then
        sgn := "0x1.";
    else
        sgn := "-0x1.";
    fi;

    cat(sgn, substring(convert(round(y), hex), 2..-1), "p", pow);
end;
\end{verbatimtab}

Values which are more than $0.49999 \ulp$ away from from the nearest 
representable double precision floating-point value will output an
error message, in which case the parameters $30$ and $0.49999$ should 
be increased.

\section{Values of $\exp(i \pi / 2^n) - 1$}

The table {\em omc\_s} is generated by the following MAPLE code:
\begin{verbatimtab}
for n from 7 to 29 do
    printf("%s, %s,\n", r(cos(2 * Pi / 2^n) - 1), r(sin(2 * Pi / 2^n)));
od;
\end{verbatimtab}
and, taking $w_{k + 7} = \textrm{omc\_s}_{2 k} + i \textrm{omc\_s}_{2 k + 1}$,
satisfies
$$
w_k \approx \exp(2 i \pi / 2^k) - 1
$$
for $7 \leq k \leq 29$.
*/

static double omc_s[] = {
#if 0
    -0x1.3BC390D250439p-10, 0x1.91F65F10DD814p-5,
    -0x1.3BCFBD9979A27p-12, 0x1.92155F7A3667Ep-6,
    -0x1.3BD2C8DA49511p-14, 0x1.921D1FCDEC784p-7,
    -0x1.3BD38BAB6D94Cp-16, 0x1.921F0FE670071p-8,
    -0x1.3BD3BC5FC5AB4p-18, 0x1.921F8BECCA4BAp-9,
    -0x1.3BD3C88CDCA13p-20, 0x1.921FAAEE6472Ep-10,
    -0x1.3BD3CB98226DCp-22, 0x1.921FB2AECB360p-11,
    -0x1.3BD3CC5AF3E1Dp-24, 0x1.921FB49EE4EA6p-12,
    -0x1.3BD3CC8BA83EEp-26, 0x1.921FB51AEB57Cp-13,
    -0x1.3BD3CC97D5562p-28, 0x1.921FB539ECF31p-14,
    -0x1.3BD3CC9AE09BFp-30, 0x1.921FB541AD59Ep-15,
    -0x1.3BD3CC9BA36D7p-32, 0x1.921FB5439D73Ap-16,
    -0x1.3BD3CC9BD421Cp-34, 0x1.921FB544197A1p-17,
    -0x1.3BD3CC9BE04EEp-36, 0x1.921FB544387BAp-18,
    -0x1.3BD3CC9BE35A2p-38, 0x1.921FB544403C1p-19,
    -0x1.3BD3CC9BE41CFp-40, 0x1.921FB544422C2p-20,
    -0x1.3BD3CC9BE44DBp-42, 0x1.921FB54442A83p-21,
    -0x1.3BD3CC9BE459Dp-44, 0x1.921FB54442C73p-22,
    -0x1.3BD3CC9BE45CEp-46, 0x1.921FB54442CEFp-23,
    -0x1.3BD3CC9BE45DAp-48, 0x1.921FB54442D0Ep-24,
    -0x1.3BD3CC9BE45DDp-50, 0x1.921FB54442D16p-25,
    -0x1.3BD3CC9BE45DEp-52, 0x1.921FB54442D18p-26,
    -0x1.3BD3CC9BE45DEp-54, 0x1.921FB54442D18p-27,
#else
-1.2045437948276074e-03,
4.9067674327418015e-02,
-3.0118130379577990e-04,
2.4541228522912288e-02,
-7.5298160855459076e-05,
1.2271538285719925e-02,
-1.8824717398857342e-05,
6.1358846491544753e-03,
-4.7061904238284885e-06,
3.0679567629659761e-03,
-1.1765482980900709e-06,
1.5339801862847657e-03,
-2.9413711778083979e-07,
7.6699031874270449e-04,
-7.3534282148855273e-08,
3.8349518757139556e-04,
-1.8383570706191654e-08,
1.9174759731070332e-04,
-4.5958926871090279e-09,
9.5873799095977345e-05,
-1.1489731724373266e-09,
4.7936899603066881e-05,
-2.8724329315058605e-10,
2.3968449808418219e-05,
-7.1810823290224899e-11,
1.1984224905069707e-05,
-1.7952705822717376e-11,
5.9921124526424275e-06,
-4.4881764556894156e-12,
2.9960562263346608e-06,
-1.1220441139229834e-12,
1.4980281131690111e-06,
-2.8051102848078523e-13,
7.4901405658471574e-07,
-7.0127757120198755e-14,
3.7450702829238413e-07,
-1.7531939280049843e-14,
1.8725351414619535e-07,
-4.3829848200124703e-15,
9.3626757073098084e-08,
-1.0957462050031182e-15,
4.6813378536549095e-08,
-2.7393655125077959e-16,
2.3406689268274554e-08,
-6.8484137812694898e-17,
1.1703344634137277e-08,
#endif
};

/**T
\pagebreak
\section{Values of $\exp(2 k i \pi / 2^6)$}
The table {\em c\_s} was constructed by the following MAPLE code:
\begin{verbatimtab}
for k from 0 to 8 do
    printf("%s, %s,\n", r(cos(2 * Pi * k / 2^6)),
        r(sin(2 * Pi * k / 2^6)));
od;
\end{verbatimtab}
and, taking $w_k = \textrm{c\_s}_{2 k} + i \textrm{c\_s}_{2 k + 1}$,
satisfies
$$ w_k \approx \exp(2 k i \pi / 2^6) $$
for $0 \leq k \leq 8$.
*/

static double c_s[] = {
#if 0
    0x1.0000000000000p0, 0.0,
    0x1.FD88DA3D12526p-1, 0x1.917A6BC29B42Cp-4,
    0x1.F6297CFF75CB0p-1, 0x1.8F8B83C69A60Bp-3,
    0x1.E9F4156C62DDAp-1, 0x1.294062ED59F06p-2,
    0x1.D906BCF328D46p-1, 0x1.87DE2A6AEA963p-2,
    0x1.C38B2F180BDB1p-1, 0x1.E2B5D3806F63Bp-2,
    0x1.A9B66290EA1A3p-1, 0x1.1C73B39AE68C8p-1,
    0x1.8BC806B151741p-1, 0x1.44CF325091DD6p-1,
    0x1.6A09E667F3BCDp-1, 0x1.6A09E667F3BCDp-1,
#else
1.0000000000000000e+00,
0.0000000000000000e+00,
9.9518472667219693e-01,
9.8017140329560604e-02,
9.8078528040323043e-01,
1.9509032201612828e-01,
9.5694033573220882e-01,
2.9028467725446239e-01,
9.2387953251128674e-01,
3.8268343236508978e-01,
8.8192126434835505e-01,
4.7139673682599764e-01,
8.3146961230254524e-01,
5.5557023301960218e-01,
7.7301045336273699e-01,
6.3439328416364549e-01,
7.0710678118654757e-01,
7.0710678118654757e-01,
#endif
};

/**T
\section{Computation of $\exp(2 k i \pi / 2^{29})$}

We make use of the following three recurrences:
\begin{enumerate}
\item $\exp(i (x + \pi / 4)) =
    i \cdot {\rm conjugate}(\exp(i (\pi / 4 - x)))$.
\item For $k$ not a multiple of $2^{n - 6}$, $0 \leq k < 2^{n - 3}$,
$0 \leq q < 2^3$, $0 < r < 2^{n - 6}$, $k = q 2^{n - 6} + r$,
$$
\exp(2 \pi i k / 2^n) = \exp(2 \pi i q / 2^6)
    + \exp(2 \pi i q / 2^6) \cdot (\exp(2 \pi i r / 2^n) - 1)
$$
\item For $2^{n - m} < k < 2^{n - m + 1} \leq 2^{n - 6}$,
$k = 2^{n - m} + r$,
$$
\exp(2 \pi i k / 2^n) - 1 = x_0 + x_1 + x_0 x_1
$$
where $x_0 = \exp(2 \pi i / 2^m) - 1$,
$x_1 = \exp(2 \pi i r / 2^n) - 1$.
\end{enumerate}
and note that, together with tables of $\exp(2 \pi i k / 2^6)$ for
$0 \leq k \leq 2^3$ and $\exp(2 \pi i / 2^m) - 1$ for ${7 \leq m \leq 
29}$, these permit the computation of $\exp(2 \pi i k / 2^{29})$ for $0 
\leq k < 2^{27}$.

The function {\em expm1\_tbl}($LUT$, $n$, $m$) computes the complex 
values $\exp(2 \pi i k / 2^{m + 7}) - 1$ for $0 \leq k < 2^n$ and 
writes them into $LUT$.  The inputs must satisfy $0 \leq m \leq 22$,
$0 \leq n \leq m + 1$, and $LUT$ must have space to store $2^{n + 1}$ 
doubles (i.e., $2^{n + 4}$ bytes).
*/

static void expm1_tbl(real * LUT, int n, int m)
{
    double x0r, x0i, x1r, x1i;
    unsigned i, N;

    if (n == 0) {
        LUT[0] = 0.0;
        LUT[1] = 0.0;
    } else {
        expm1_tbl(LUT, n - 1, m);

        x0r = omc_s[2 * (m + 1 - n)];
        x0i = omc_s[2 * (m + 1 - n) + 1];

        N = 1 << (n - 1);
        for (i = 0; i < N; i++) {
            x1r = LUT[2 * i];
            x1i = LUT[2 * i + 1];

            LUT[2 * (i + N)]     = (real)(x0r + (x1r + (x0r * x1r - x0i * x1i)));
            LUT[2 * (i + N) + 1] = (real)(x0i + (x1i + (x0r * x1i + x0i * x1r)));
        }
    }
}

/**T
\begin{lemma}
Given $LUT$ as produced by {\em expm1\_tbl}($LUT$, $n$, $m$) and 
making the assignment ${w_k = LUT_{2 k} + i LUT_{2 k + 1}}$,
$$
\abs{w_k + 1 - \exp(2 \pi i k / 2^{m + 7})}
    < 12.75 \epsilon \cdot 2^n / 2^{m + 7}
        + \sum_{j = m + 1 - n}^{m}{\abs{W_j - \widehat{W}_j}}
$$
for all $0 \leq k < 2^n$, where $W_j = \exp(2 \pi i / 2^{j + 7}) - 1$ 
and  $\widehat{W}_j$ is the value of $W_j$ as stored in {\em omc\_s}.

Further, if $n = m + 1$, then
$$
\abs{w_k + 1 - \exp(2 \pi i k / 2^{m + 7})}
    < 14 \epsilon / 64
$$
for all $0 \leq k < 2^n$.
\end{lemma}
\begin{proof}
We prove the first part by induction.  If $n = 0$, then there is 
clearly no error, and the result holds.  Now assume that the result 
holds for $n = n_0 \leq m$, and consider the behaviour of
{\em expm1\_tbl}($LUT$, $n_0 + 1$, $m$).

Since {\em expm1\_tbl}($LUT$, $n_0 + 1$, $m$) calls
{\em expm1\_tbl}($LUT$, $n_0$, $m$) and does not subsequently modify 
the first $2^{n_0}$ complex values stored in $LUT$, the required 
result holds for $0 \leq k < 2^{n_0}$; consequently, we need only 
prove that the result holds for $2^{n_0} \leq k < 2^{n_0 + 1}$.

For such a $k$, $w_k$ is computed as
$$
w_k := x_0 + \left( w_{k - 2^{n_0}} + x_0 w_{k - 2^{n_0}} \right)
$$
and where $x_0$ is the value of $\exp(2 i \pi 2^{n_0} / 2^{m + 7}) - 1$ 
obtained from {\em omc\_s}.  The error in $w_k$ is therefore the sum of 
the following:
\begin{enumerate}
\item The error introduced in computing the complex product
$x_0 w_{k - 2^{n_0}}$.  The relative error in computing a complex 
product less than $\epsilon \sqrt{5}$~\cite{BPZ05}, so this error
is less than $\epsilon \sqrt{5} \abs{x_0} \abs{w_{k - 2^{n_0}}}$.  
Since $\abs{\exp(i x) - 1} < x$ for $x > 0$, we note that
$\abs{w_{k - 2^{n_0}}} \leq \abs{x_0} \leq 2 \pi 2^{n_0} / 2^{m + 7}
\leq \pi / 64$, and consequently the error introduced in computing
the complex product is less than
$\epsilon \sqrt{5} (\pi / 64)^2 2^{n_0} / 2^{m}$.

\item The error introduced in the addition of
$w_{k - 2^{n_0}}$ and $x_0 w_{k - 2^{n_0}}$.  The real and imaginary 
parts of this error are bounded by half of the $\ulp$ of the real and 
imaginary parts of the result respectively.  Since the result of this 
addition is approximately equal to $\exp(2 \pi i k / 2^{m + 7}) - 
\exp(2 \pi i 2^{n_0} / 2^{m + 7})$, the real error is bounded by
\begin{align*}
\frac{1}{2} \ulp(\cos(2 \pi 2^{n_0 + 1} / 2^{m + 7}) - \cos(2 \pi 
    2^{n_0} / 2^{m + 7}))
& = \frac{1}{2} \ulp\left( \frac{3 (2 \pi 2^{n_0 - m - 7})^2}{2} \right) \\
& = \frac{1}{2} \ulp( 2^{2 n_0 - 2 m - 9} ) \\
& = \epsilon 2^{2 n_0 - 2 m - 9}
\end{align*}
noting that the value within $\ulp()$ can be approximated without 
changing the result.

Similarly, the real error is bounded by
\begin{align*}
\frac{1}{2} \ulp(\sin(2 \pi 2^{n_0 + 1} / 2^{m + 7}) - \sin(2 \pi 
    2^{n_0} / 2^{m + 7}))
& = \frac{1}{2} \ulp(2 \pi 2^{n_0} / 2^{m + 7})     \\
& = \epsilon 2^{n_0 - m - 5}
\end{align*}
and thus the absolute complex error is bounded by
\begin{align*}
\epsilon
\sqrt{\left(2^{2 n_0 - 2 m - 9}\right)^2 + \left(2^{n_0 - m - 5}\right)^2}
& = \epsilon 2^{n_0 - m - 5} \sqrt{1 + 2^{2 n_0 - 2 m - 8}} \\
& \leq \epsilon 2^{n_0 - m - 5} \sqrt{\frac{257}{256}}
    \leq 1.002 \epsilon \cdot 2^{n_0 - m - 5}
\end{align*}

\item The error introduced in computing the sum of
$x_0$ and $w_{k - 2^{n_0}} + x_0 w_{k - 2^{n_0}}$.
Following the same argument as above, the real error is bounded by
\begin{align*}
\frac{1}{2} \ulp(\cos(2 \pi 2^{n_0 + 1} / 2^{m + 7}) - 1))
    & = \frac{1}{2} \ulp(\frac{(2 \pi 2^{n_0 + 1} / 2^{m + 
        7})^2}{2})  \\
    & = \epsilon 2^{2 n_0 - 2 m - 8}
\end{align*}
and the imaginary error is bounded by
\begin{align*}
\frac{1}{2} \ulp(\sin(2 \pi 2^{n_0 + 1} / 2^{m + 7}))
    & = \frac{1}{2} \ulp(2 \pi 2^{n_0 + 1} / 2^{m + 7}) \\
    & = \epsilon 2^{n_0 - m - 4}
\end{align*}
and consequently the absolute complex error is bounded by
\begin{align*}
\epsilon
\sqrt{\left(2^{2 n_0 - 2 m - 8}\right)^2 + \left(2^{n_0 - m - 4}\right)^2}
& = \epsilon2^{n_0 - m - 4} \sqrt{1 + 2^{2 n_0 - 2 m - 8}}  \\
& \leq \epsilon 2^{n_0 - m - 4} \sqrt{\frac{257}{256}}
    \leq 1.002 \epsilon \cdot 2^{n_0 - m - 4}
\end{align*}
\item The error introduced from inaccuracy in the input $x_0$.  This is
$\abs{W_{m - n_0} - \widehat{W}_{m - n_0}}$ for $W$ as defined earlier.
\item The error introduced from inaccuracy in $w_{k - 2^{n_0}}$.  By 
assumption, this is bounded by
$$
12.75 \epsilon \cdot 2^{n_0} / 2^{m + 7}
    + \sum_{j = m + 1 - n_0}^{m}{\abs{W_j - \widehat{W}_j}}
$$
\end{enumerate}

Adding these together, we obtain
\begin{align*}
\abs{w_k + 1 - \exp(2 \pi i k / 2^{m + 7})}
& < \epsilon \left(12 \cdot 1.002 +
        \frac{\pi^2 \sqrt{5}}{32}\right) 2^{n_0} / 2^{m + 7}
    + \abs{W_{m - n_0} - \widehat{W}_{m - n_0}}     \\
    & \qquad
    + 12.75 \epsilon \cdot 2^{n_0} / 2^{m + 7}
    + \sum_{j = m + 1 - n_0}^{m}{\abs{W_j - \widehat{W}_j}} \\
& < 12.75 \epsilon \cdot 2^{n_0 + 1} / 2^{m + 7}
    + \sum_{j = m - n_0}^{m}{\abs{W_j - \widehat{W}_j}}
\end{align*}
for all $2^{n_0} \leq k < 2^{n_0 + 1}$ and the result follows.

To establish the second part of the proof, we compute the sum using the 
following MAPLE code
\begin{verbatimtab}
Digits := 50;

ERR_e := proc(x)
    local y, pow;

    if x = 0 then RETURN(0); fi;
    y := abs(x);
    pow := floor(log[2.](y));
    evalf(y - round(y * 2^(52 - pow)) * 2^(pow - 52)) * 2^53;
end;

ERR_c := z -> sqrt(ERR_e(Re(z))^2 + ERR_e(Im(z))^2);

sum( ERR_c(exp(2 * Pi * I / 2^n) - 1), n = 7..29);
\end{verbatimtab}
and obtain $0.01689\ldots \epsilon < 1.25 \epsilon / 64$; adding this 
to the other $12.75 \epsilon / 64$ provides the stated bound.
\end{proof}

The function {\em tricl\_roots\_makelut}($LUT$, $n$) computes the 
complex values $\exp(2 \pi i k / 2^n)$ for ${0 \leq k < 2^{n - 2}}$.  
The value $n$ must satisfy $2 \leq n \leq 29$, and $LUT$ must have 
space to store $2^{n - 1}$ doubles (i.e., $2^{n + 2}$ bytes).
*/

/**T
For inputs $2 \leq n \leq 29$, {\em tricl\_roots\_makelut} computes the 
value $\exp(2 \pi i k / 2^n)$ for all values ${0 \leq k < 2^{n - 2}}$, 
and stores the real part into {\em LUT}[$2 k$] and the imaginary part 
into {\em LUT}[$2 k + 1$].  {\em LUT} must be a pointer to sufficient 
space to store $2^{n - 1}$ doubles.

The complex values stored are within $1.5 \cdot 2^{-53}$ of the exact 
values.
*/
void tricl_roots_makelut(real * LUT, int n)
{
    double x0r, x0i, x1r, x1i;
    int i, j, N;

    assert(2 <= n && n <= 29);

    if (n == 2) {
        /* We only want k = 0 */
        LUT[0] = 1.0;
        LUT[1] = 0.0;
    } else if (n <= 6) {
        /* Copy values of exp(i x) for 0 <= x < pi / 4 from c_s[] */
        N = 1 << (6 - n);
        for (i = 0; i < (1 << (n - 3)); i++) {
            LUT[2 * i] =     (real)c_s[2 * i * N];
            LUT[2 * i + 1] = (real)c_s[2 * i * N + 1];
        }

        /* Copy value of exp(i pi / 4) */
        LUT[2 * (1 << (n - 3))] =     (real)c_s[2 * 8];
        LUT[2 * (1 << (n - 3)) + 1] = (real)c_s[2 * 8 + 1];

        /*-
         * Continue by noting that
         * exp(i (x + pi / 4)) = i conj(exp(i (pi / 4 - x)))
         */
        for (i = (1 << (n - 3)) + 1; i < (1 << (n - 2)); i++) {
            LUT[2 * i + 1] = LUT[2 * ((1 << (n - 2)) - i)];
            LUT[2 * i] = LUT[2 * ((1 << (n - 2)) - i) + 1];
        }
    } else {
        /*
         * Compute exp(2 pi i k / 2^n) - 1 for 0 <= k < 2^(n - 6)
         */
        expm1_tbl(LUT, n - 6, n - 7);

        /*
         * Combine with appropriate exp(2 pi i k / 2^6) to 
         * obtain exp(2 pi i k / 2^n) for 0 <= k < 2^(n - 3)
         */
        N = 1 << (n - 6);
        for (i = 7; i >= 0; i--) {
            for (j = 0; j < N; j++) {
                x0r = (real)c_s[2 * i];
                x0i = (real)c_s[2 * i + 1];
                x1r = LUT[2 * j];
                x1i = LUT[2 * j + 1];

                LUT[2 * (i * N + j)] = (real)(x0r
                    + (x0r * x1r - x0i * x1i));
                LUT[2 * (i * N + j) + 1] = (real)(x0i
                    + (x0r * x1i + x0i * x1r));
            }
        }

        /* Copy value of exp(i pi / 4) */
        LUT[2 * (1 << (n - 3))] = (real)c_s[2 * 8];
        LUT[2 * (1 << (n - 3)) + 1] = (real)c_s[2 * 8 + 1];

        /*-
         * Continue by noting that
         * exp(i (x + pi / 4)) = i conj(exp(i (pi / 4 - x)))
         */
        for (i = (1 << (n - 3)) + 1; i < (1 << (n - 2)); i++) {
            LUT[2 * i + 1] = LUT[2 * ((1 << (n - 2)) - i)];
            LUT[2 * i] = LUT[2 * ((1 << (n - 2)) - i) + 1];
        }
    }

    return;
}

/**T
\begin{theorem}
Given $LUT$ as produced by {\em tricl\_roots\_makelut}($LUT$, $n$)
with $2 \leq n \leq 29$, and making the assignment
${w_k = LUT_{2 k} + i LUT_{2 k + 1}}$,
$$
\abs{w_k - \exp(2 \pi i k / 2^n)} < \frac{3}{2} \epsilon
$$
for all $0 \leq k < 2^{n - 2}$.
\end{theorem}
\begin{proof}
For $n = 2$, there is only one value produced, and it is given exactly.
For $2 < n \leq 6$, the values are copied from the table {\em c\_s}, 
and the maximum error is trivially $\sqrt{1/2} \epsilon$, well below 
the bound to be proven.  We therefore need only consider the third case 
in the code, where $n > 6$.

In this case, the value $w_k$ is computed as $x_0 + x_0 x_1$, where 
$x_0$ is the $2^6$th root of unity $\exp(2 \pi i k^\prime / 2^6)$ for 
$k^\prime = \floor{k / 2^{n - 6}}$, as stored in the table {\em c\_s}, 
and $x_1$ is the value $\exp(2 \pi i (k - k^\prime 2^{n - 6}) / 2^{n}) 
- 1$ as generated by {\em expm1\_tbl}($LUT$, $n - 6$, $n - 7$).  The 
error in the values computed is consequently the sum of the following:
\begin{enumerate}
\item The error introduced from inaccuracy in $x_0$.  Since
$\abs{1 + x_1} = 1$, this has the same norm as the error in the stored 
value of $x_0$, i.e., one of $8$ possible values depending upon 
$k^\prime$.
\item The error introduced from inaccuracy in $x_1$.  Since $\abs{x_0} 
= 1$, this has the same norm as the error in the computed value of 
$x_1$, which is bounded from above by $14 \epsilon / 64$ as shown in 
Lemma 1.
\item The error introduced by rounding errors in computing
$x_0 + x_0 x_1$.  The real and imaginary parts of this each consist of 
four elements: Two errors introduced by multiplications in computing 
the complex product $x_0 x_1$; the error introduced by the addition 
used in computing the complex product $x_0 x_1$; and the error 
introduced by the addition of $x_0$ and $x_0 x_1$.

Considering the largest possible values at each point in the 
computation, we note that the real part of this introduced error is 
bounded by
\begin{align*}
& \frac{1}{2}\ulp(\cos(2 \pi k^\prime / 2^n))
    + \frac{1}{2}\ulp(\cos(2 \pi k^\prime / 2^n)
        - \cos(2 \pi (k^\prime + 1) / 2^n)) \\
& \qquad
    + \frac{1}{2}\ulp(\cos(2 \pi k^\prime / 2^n)
        (1 - \cos(2 \pi / 2^n)))
    + \frac{1}{2}\ulp(\sin(2 \pi k^\prime / 2^n)
        \sin(2 \pi / 2^n)))
\end{align*}
and the imaginary part is bounded by
\begin{align*}
& \frac{1}{2}\ulp(\sin(2 \pi (k^\prime + 1)/ 2^n))
    + \frac{1}{2}\ulp(\sin(2 \pi (k^\prime + 1) / 2^n)
        - \sin(2 \pi k^\prime / 2^n))   \\
& \qquad
    + \frac{1}{2}\ulp(\sin(2 \pi k^\prime / 2^n)
        (1 - \cos(2 \pi / 2^n)))
    + \frac{1}{2}\ulp(\cos(2 \pi k^\prime / 2^n)
        \sin(2 \pi / 2^n)))
\end{align*}
For each of the $8$ possible values of $k^\prime$, these two bounds can 
be computed, and thereby a bound on the largest absolute error 
introduced by new rounding errors.
\end{enumerate}

By computation, the sum of the bounds given above is maximized for 
$k^\prime = 6$, where we obtain the maximum error bound of $1.488\ldots 
\epsilon$, below the required bound of $1.5 \epsilon$.
\end{proof}

\begin{theorem}
The $2^n$th roots of unity can be computed in double precision using
$2 n + 6$ precomputed values and $\frac{37}{32} 2^n$ double precision 
floating-point operations, with a maximum absolute error of less than 
$1.5 \epsilon$.
\end{theorem}
\begin{proof}
The function {\em tricl\_roots\_makelut} behaves as required.
\end{proof}

For arbitrary precisions, the precise error bound will vary (since the 
precise errors in the precomputed constants will be different), but 
will always be less than $2 \epsilon$ for the relevant $\epsilon$.

\bibliographystyle{amsplain}
\begin{thebibliography}{X}

\bibitem{BPZ05} R.P.~Brent, C.~Percival, P.~Zimmermann, \textit{Error 
Bounds on Complex Floating-Point Multiplication}, manuscript.
\end{thebibliography}
*/

/**T
\section{FFT normalization}
The FFT and inverse FFT given in fft.c are unnormalized, i.e., the 
length-$N$ FFT followed by a length-$N$ inverse FFT leaves the output 
equal to $N$ times the input.  To remedy this, the function
{\em tricl\_fftconv\_scale}($DAT$, $n$) should be called at some point.

As in fft.c, $n$ must satisfy $0 \leq n \leq 29$, and $DAT$ must be an 
array of $2^n$ complex values ($2^{n + 1}$ doubles).
*/
void tricl_fftconv_scale(real * DAT, int n)
{
    double s;
    int i;

    assert(0 <= n && n <= 29);

    s = ldexp(1.0, -n);
    for (i = 0; i < 2 << n; i++)
        DAT[i] = (real)(DAT[i] * s);
}

/**T
\section{Pointwise complex products}

The function {\em tricl\_fftconv\_mulpw}($DAT1$, $DAT2$, $n$) computes 
the product of $2^n$ pairs of complex values from $DAT1$ and $DAT2$ and 
writes the resulting values into $DAT1$.

As usual, $n$ must satisfy $0 \leq n \leq 29$, and $DAT1$ and $DAT2$ 
must be non-overlapping arrays of $2^n$ complex values ($2^{n + 1}$ 
doubles).
*/
void tricl_fftconv_mulpw(real * __restrict DAT1, real * __restrict DAT2, int n)
{
    real xr, xi;
    int i;

    assert(0 <= n && n <= 29);

    for (i = 0; i < 1 << n; i++) {
        xr = DAT1[i * 2];
        xi = DAT1[i * 2 + 1];

        DAT1[i * 2] = xr * DAT2[i * 2] - xi * DAT2[i * 2 + 1];
        DAT1[i * 2 + 1] = xr * DAT2[i * 2 + 1] + xi * DAT2[i * 2];
    }
}

/**T
The function {\em tricl\_fftconv\_sqrpw}($DAT$, $n$) squares $2^n$ 
complex values from $DAT$ and writes the resulting values into $DAT$.

As usual, $n$ must satisfy $0 \leq n \leq 29$, and $DAT$ must be an 
array of $2^n$ complex values ($2^{n + 1}$ doubles).
*/
void tricl_fftconv_sqrpw(real * DAT, int n)
{
    real xr, xi;
    int i;

    assert(0 <= n && n <= 29);

    for (i = 0; i < 1 << n; i++) {
        xr = DAT[i * 2];
        xi = DAT[i * 2 + 1];

        DAT[i * 2] = xr * xr - xi * xi;
        DAT[i * 2 + 1] = 2 * xr * xi;
    }
}

/**T
\section{FFT convolution}

To compute a length-$2^n$ convolution of two vectors $X$ and $Y$:
\begin{verbatim}
tricl_fft_makelut(LUT, n);
tricl_fft_fft(X, n, LUT);
tricl_fft_fft(Y, n, LUT);
tricl_fftconv_mulpw(X, Y, n);
tricl_fft_ifft(X, n, LUT);
tricl_fftconv_scale(X, n);
\end{verbatim}
although the call to tricl\_fftconv\_scale can be performed at any 
point in the process, and on either $X$ or $Y$.

\begin{theorem}
When computed in this manner, the convolution $z$ of two length-$2^n$ 
complex vectors $x$ and $y$ will satisfy
$$
\abs{z^\prime - z}_\infty < \abs{x} \cdot \abs{y} \cdot
    \left((1 + \epsilon)^{3 n} (1 + \epsilon \sqrt{5})^{3 n + 1}
        (1 + 1.5 \epsilon)^{3 n} - 1\right)
    < \abs{x} \cdot \abs{y} \cdot (14.3 n + 2.3) \epsilon
$$
where $\epsilon = 2^{-53}$ is the maximum relative error in 
double-precision floating-point arithmetic.
\end{theorem}
\begin{proof}
The FFT used is a split-radix FFT, not a radix-2 FFT, but the argument 
from Theorem 5.1 of \cite{Per03} still applies (the only difference as 
far as error bounds are concerned is that the split-radix FFT has fewer 
complex multiplications; but this reduction does not affect the worst 
case).  From \cite{rootsc} we note that we can take $\beta = 1.5 
\epsilon$ to complete the proof.
\end{proof}

\bibliographystyle{amsplain}
\begin{thebibliography}{X}

\bibitem{Per03} C.~Percival, \textit{Rapid multiplication modulo the 
sum and difference of highly composite numbers}, Math. Comp. 
\textbf{72} (2003), 387--395.

\bibitem{rootsc} C.~Percival, \textit{roots.c}, in \textit{TRICL},
{\tt http://www.daemonology.net/tricl/}, (2005).
\end{thebibliography}
*/

void mulr2(real *a,real *b)
{
  register real t1, t2;

  t1 = a[0] * b[0];
  t2 = a[1] * b[1];
  a[0] = t1;
  a[1] = t2;
}

void mulr4(real *a,real *b)
{
  register real t1, t2, t3, t4, t5, t6;

  t1 = a[2] * b[2];
  t2 = a[3] * b[3];
  t3 = a[3] * b[2];
  t4 = a[2] * b[3];
  t5 = a[0] * b[0];
  t6 = a[1] * b[1];
  t1 -= t2;
  t3 += t4;
  a[0] = t5;
  a[1] = t6;
  a[2] = t1;
  a[3] = t3;
}

void tricl_fftconv_mulpr_conj(real * __restrict DAT1, real * __restrict DAT2, int n)
{
    real xr, xi;
    int i;

    assert(0 <= n && n <= 29);
    if (n >= 1) {mulr2(DAT1,DAT2); }

    for (i = 1; i < 1 << n >> 1; i++) {
        xr = DAT1[i * 2];
        xi = DAT1[i * 2 + 1];

        DAT1[i * 2] = xr * DAT2[i * 2] + xi * DAT2[i * 2 + 1];
        DAT1[i * 2 + 1] = -xr * DAT2[i * 2 + 1] + xi * DAT2[i * 2];
    }
}

void tricl_fftconv_mulpr(real * __restrict DAT1, real * __restrict DAT2, int n)
{
    real xr, xi;
    int i;

    assert(0 <= n && n <= 29);
    if (n >= 1) {mulr2(DAT1,DAT2); }

    for (i = 1; i < 1 << n >> 1; i++) {
        xr = DAT1[i * 2];
        xi = DAT1[i * 2 + 1];

        DAT1[i * 2] = xr * DAT2[i * 2] - xi * DAT2[i * 2 + 1];
        DAT1[i * 2 + 1] = xr * DAT2[i * 2 + 1] + xi * DAT2[i * 2];
    }
}



/**T
\section{Twiddle factors}
*/

/**T
The function {\em tricl\_fft\_makelut}($LUT$, $n$) generates an FFT lookup
table suitable for use in computing FFTs of length up to $2^n$.  This table is
in fact a series of tables of sizes $4$, $8$, $16$, \ldots $2^{n - 2}$ complex
values; the table of size $2^{k - 2}$ contains the $2^k$th roots of unity
in the first quadrant, in order of increasing angle.

For example, {\em tricl\_fft\_makelut}($LUT$, $32$) would generate a table
containing the following values:
\begin{align*}
0       & + 0 i         \\
0       & + 0 i         \\
0       & + 0 i         \\
0       & + 0 i         \\
cos(0)      & + sin(0) i        \\
cos(\pi / 8)    & + sin(\pi / 8) i      \\
cos(\pi / 4)    & + sin(\pi / 4) i      \\
cos(3 \pi / 8)  & + sin(3 \pi / 8) i    \\
cos(0)      & + sin(0) i        \\
cos(\pi / 16)   & + sin(\pi / 16) i     \\
cos(\pi / 8)    & + sin(\pi / 8) i      \\
cos(3 \pi / 16) & + sin(3 \pi / 16) i   \\
cos(\pi / 4)    & + sin(\pi / 4) i      \\
cos(5 \pi / 16) & + sin(5 \pi / 16) i   \\
cos(3 \pi / 8)  & + sin(3 \pi / 8) i    \\
cos(7 \pi / 16) & + sin(7 \pi / 16) i
\end{align*}
(Note that the first four complex values are left zeroed, in order that the
table of size $N$ starts at the $N$th complex value.)

The input $n$ must satisfy $0 \leq n \leq 29$, and $LUT$ must have space to
store $2^n$ doubles (i.e., $2^{n + 3}$ bytes).
*/

void tricl_fft_makelut(real * LUT, int n)
{
    int i;

    assert(0 <= n && n <= 29);

    /**T If $n < 4$, we just need to write $2^n$ zeroes. */
    if (n < 4) {
        for (i = 0; i < (1 << n); i++)
            LUT[i] = 0.0;
        return;
    }

    /**T Otherwise, write $8$ zeroes\ldots */
    for (i = 0; i < 8; i++)
        LUT[i] = 0.0;

    /**T\ldots generate the table of size $2^{n - 2}$\ldots*/
    tricl_roots_makelut(LUT + ((size_t)1 << (n - 1)), n);

    /**T\ldots and then generate the smaller tables by copying every
        second value from the next larger table. */
    for (i = (1 << (n - 1)) - 2; i >= 8; i -= 2) {
        LUT[i] = LUT[i * 2];
        LUT[i + 1] = LUT[i * 2 + 1];
    }
}

/**T
\section{The FFT}
We use a recursive ``exponent -1'' split-radix decimation-in-frequency FFT,
based roughly on ideas from Bernstein~\cite{DJB99}.

\subsection{Building blocks}
We build the FFT and inverse FFT out of seven primative blocks: {\em FFT\_PM},
{\em FFT\_SRM} and {\em IFFT\_SRM}, {\em FFT\_SRM\_PI\_4} and
{\em IFFT\_SRM\_PI\_4}, and {\em FFT\_SRM\_W} and {\em IFFT\_SRM\_W}.

The macro {\em FFT\_PM} transforms $(a, b)$ into $(a + b, a - b)$, i.e., it
performs a length-$2$ FFT (which is also a length-$2$ inverse FFT).
*/

#define FFT_PM(a, b) {    \
    real t;       \
                \
    t = (b)[0];     \
    (b)[0] = (a)[0] - t;    \
    (a)[0] += t;        \
    t = (b)[1];     \
    (b)[1] = (a)[1] - t;    \
    (a)[1] += t;        \
}

/**T
The macro {\em FFT\_SRM} performs ``split-radix mixing'' of four values: It
transforms $(a, b, c, d)$ into
$(a + c, b + d, (a - c) + (b - d) i, (a - c) - (b - d) i)$ -- this equates
to one pass of FFT on half the data and two passes of FFT minus twiddling
on the other half of the data.

The macro {\em IFFT\_SRM} is the inverse of {\em FFT\_SRM}.
*/

#define FFT_SRM(a, b, c, d) {    \
    real t0r, t0i, t1r, t1i;  \
                    \
    t0r = (a)[0] - (c)[0];      \
    (a)[0] += (c)[0];       \
    t0i = (a)[1] - (c)[1];      \
    (a)[1] += (c)[1];       \
    t1r = (b)[0] - (d)[0];      \
    (b)[0] += (d)[0];       \
    t1i = (b)[1] - (d)[1];      \
    (b)[1] += (d)[1];       \
                    \
    (c)[0] = t0r - t1i;     \
    (d)[0] = t0r + t1i;     \
    (c)[1] = t0i + t1r;     \
    (d)[1] = t0i - t1r;     \
}

#define IFFT_SRM(a, b, c, d) {        \
    real t0r, t0i, t1r, t1i, t2r, t2i;    \
                        \
    t2r = (c)[0];               \
    t2i = (c)[1];               \
    t0r = t2r + (d)[0];         \
    t0i = t2i + (d)[1];         \
    t1r = t2i - (d)[1];         \
    t1i = (d)[0] - t2r;         \
                        \
    (c)[0] = (a)[0] - t0r;          \
    (a)[0] += t0r;              \
    (c)[1] = (a)[1] - t0i;          \
    (a)[1] += t0i;              \
    (d)[0] = (b)[0] - t1r;          \
    (b)[0] += t1r;              \
    (d)[1] = (b)[1] - t1i;          \
    (b)[1] += t1i;              \
}

/**T
The macro {\em FFT\_SRM\_PI\_4} performs split-radix mixing and twiddling of
four values: It transforms $(a, b, c, d)$ into
$(a + c, b + d, ((a - c) + (b - d) i) w, ((a - c) - (b - d)i) \bar{w})$ where
$w = \exp(i \pi / 4) = (1 + i) / \sqrt{2}$.  This is equivalent to
{\em FFT\_SRM} followed by rotating $c$ left by $\pi / 4$ and rotating $d$
right by $\pi / 4$.

The macro {\em IFFT\_SRM\_PI\_4} is the inverse of {\em FFT\_SRM\_PI\_4}.
*/

#define SQRTHALF TRICL_ROOTS_SQRTHALF

#define FFT_SRM_PI_4(a, b, c, d)  {    \
    double t0r, t0i, t1r, t1i, t2r, t2i;    \
                        \
    t0r = (a)[0] - (c)[0];          \
    (a)[0] += (c)[0];           \
    t0i = (a)[1] - (c)[1];          \
    (a)[1] += (c)[1];           \
    t1r = (b)[0] - (d)[0];          \
    (b)[0] += (d)[0];           \
    t1i = (b)[1] - (d)[1];          \
    (b)[1] += (d)[1];           \
                        \
    t2r = t0r - t1i;            \
    t2i = t0i + t1r;            \
    t0r += t1i;             \
    t0i -= t1r;             \
                        \
    (c)[0] = (real)((t2r - t2i) * SQRTHALF);    \
    (c)[1] = (real)((t2r + t2i) * SQRTHALF);    \
    (d)[0] = (real)((t0r + t0i) * SQRTHALF);    \
    (d)[1] = (real)((t0i - t0r) * SQRTHALF);    \
}

#define IFFT_SRM_PI_4(a, b, c, d)  {    \
    double t0r, t0i, t1r, t1i, t2r, t2i;    \
                        \
    t0r = ((c)[0] + (c)[1]) * SQRTHALF; \
    t0i = ((c)[1] - (c)[0]) * SQRTHALF; \
    t1r = ((d)[0] - (d)[1]) * SQRTHALF; \
    t1i = ((d)[0] + (d)[1]) * SQRTHALF; \
                        \
    t2r = t0i - t1i;            \
    t2i = t1r - t0r;            \
    t0r += t1r;             \
    t0i += t1i;             \
                        \
    (c)[0] = (real)((a)[0] - t0r);          \
    (a)[0] = (real)((a)[0] + t0r);          \
    (c)[1] = (real)((a)[1] - t0i);          \
    (a)[1] = (real)((a)[1] + t0i);          \
    (d)[0] = (real)((b)[0] - t2r);          \
    (b)[0] = (real)((b)[0] + t2r);          \
    (d)[1] = (real)((b)[1] - t2i);          \
    (b)[1] = (real)((b)[1] + t2i);          \
}

/**T
The macro {\em FFT\_SRM\_W} performs split-radix mixing and twiddling of
four values: It transforms $(a, b, c, d)$ into
$(a + c, b + d, ((a - c) + (b - d) i) w, ((a - c) - (b - d)i) \bar{w})$ where
$w$ is a root of unity.

The macro {\em IFFT\_SRM\_W} is the inverse of {\em FFT\_SRM\_W}.
*/

#define FFT_SRM_W(a, b, c, d, w)  {    \
    double t0r, t0i, t1r, t1i, t2r, t2i;    \
                        \
    t0r = (a)[0] - (c)[0];          \
    (a)[0] += (c)[0];           \
    t0i = (a)[1] - (c)[1];          \
    (a)[1] += (c)[1];           \
    t1r = (b)[0] - (d)[0];          \
    (b)[0] += (d)[0];           \
    t1i = (b)[1] - (d)[1];          \
    (b)[1] += (d)[1];           \
                        \
    t2r = t0r - t1i;            \
    t2i = t0i + t1r;            \
    t0r += t1i;             \
    t0i -= t1r;             \
                        \
    (c)[0] = (real)(t2r * (w)[0] - t2i * (w)[1]);   \
    (c)[1] = (real)(t2i * (w)[0] + t2r * (w)[1]);   \
    (d)[0] = (real)(t0r * (w)[0] + t0i * (w)[1]);   \
    (d)[1] = (real)(t0i * (w)[0] - t0r * (w)[1]);   \
}

#define IFFT_SRM_W(a, b, c, d, w)  {    \
    double t0r, t0i, t1r, t1i, t2r, t2i;    \
                        \
    t0r = (c)[0] * (w)[0] + (c)[1] * (w)[1];\
    t0i = (c)[1] * (w)[0] - (c)[0] * (w)[1];\
    t1r = (d)[0] * (w)[0] - (d)[1] * (w)[1];\
    t1i = (d)[1] * (w)[0] + (d)[0] * (w)[1];\
                        \
    t2r = t0i - t1i;            \
    t2i = t1r - t0r;            \
    t0r += t1r;             \
    t0i += t1i;             \
                        \
    (c)[0] = (real)((a)[0] - t0r);          \
    (a)[0] = (real)((a)[0] + t0r);          \
    (c)[1] = (real)((a)[1] - t0i);          \
    (a)[1] = (real)((a)[1] + t0i);          \
    (d)[0] = (real)((b)[0] - t2r);          \
    (b)[0] = (real)((b)[0] + t2r);          \
    (d)[1] = (real)((b)[1] - t2i);          \
    (b)[1] = (real)((b)[1] + t2i);          \
}

/**T
\subsection{Small FFTs}
Up to length $2^4$, we provide hard-coded FFTs:
*/

static void fft_0(__unused real * __restrict DAT,
    __unused const real * __restrict LUT)
{
    UNUSED(DAT);
    UNUSED(LUT);
    /* Do nothing */
}

static void fft_1(real * __restrict DAT,
    __unused const real * __restrict LUT)
{
    UNUSED(LUT);
    FFT_PM(DAT, DAT + 2);
}

static void fft_2(real * __restrict DAT,
    __unused const real * __restrict LUT)
{
    UNUSED(LUT);
    FFT_SRM(DAT, DAT + 2, DAT + 4, DAT + 6);
    FFT_PM(DAT, DAT + 2);
}

static void fft_3(real * __restrict DAT,
    __unused const real * __restrict LUT)
{
    UNUSED(LUT);
    FFT_SRM(DAT, DAT + 4, DAT + 8, DAT + 12);
    FFT_SRM_PI_4(DAT + 2, DAT + 6, DAT + 10, DAT + 14);
    FFT_PM(DAT + 8, DAT + 10);
    FFT_PM(DAT + 12, DAT + 14);
    FFT_SRM(DAT, DAT + 2, DAT + 4, DAT + 6);
    FFT_PM(DAT, DAT + 2);
}

static void fft_4(real * __restrict DAT,
    const real * __restrict LUT)
{

    FFT_SRM(DAT, DAT + 8, DAT + 16, DAT + 24);
    FFT_SRM_W(DAT + 2, DAT + 10, DAT + 18, DAT + 26, LUT + 10);
    FFT_SRM_PI_4(DAT + 4, DAT + 12, DAT + 20, DAT + 28);
    FFT_SRM_W(DAT + 6, DAT + 14, DAT + 22, DAT + 30, LUT + 14);
    FFT_SRM(DAT + 16, DAT + 18, DAT + 20, DAT + 22);
    FFT_PM(DAT + 16, DAT + 18);
    FFT_SRM(DAT + 24, DAT + 26, DAT + 28, DAT + 30);
    FFT_PM(DAT + 24, DAT + 26);
    FFT_SRM(DAT, DAT + 4, DAT + 8, DAT + 12);
    FFT_SRM_PI_4(DAT + 2, DAT + 6, DAT + 10, DAT + 14);
    FFT_PM(DAT + 8, DAT + 10);
    FFT_PM(DAT + 12, DAT + 14);
    FFT_SRM(DAT, DAT + 2, DAT + 4, DAT + 6);
    FFT_PM(DAT, DAT + 2);
}

/**T
\subsection{Large FFTs}
For lengths $2^5$ up to $2^{29}$, we define a generic split-radix FFT macro
which outputs a function for computing that particular FFT length (doing
some computations and then recursing into the length $2^{n - 1}$ and length
$2^{n - 2}$ FFTs, as the split-radix FFT normally does).  We then construct
an array of pointers to the FFT functions and tricl\_fft\_fft looks up and
calls the correct function -- this is around 5--10\% faster than a single
recursive FFT function.

This could be made slightly faster by using {\em FFT\_SRM\_PI\_4}, but the
difference is less than 1\%, so it isn't worth the cost of the increased
code size which would result.
*/

#define FFT_FUNC(n, nm1, nm2, len)                  \
static void fft_ ## n(real * __restrict DAT,              \
    const real * __restrict LUT)                        \
{                                   \
    unsigned i;                         \
                                    \
    FFT_SRM(DAT, DAT + len * 2, DAT + len * 4, DAT + len * 6);  \
    for (i = 2; i < 2 * len; i += 2)                \
        FFT_SRM_W(DAT + i, DAT + len * 2 + i,           \
            DAT + len * 4 + i, DAT + len * 6 + i,       \
            LUT + len * 2 + i);                 \
                                    \
    fft_ ## nm2(DAT + len * 4, LUT);                \
    fft_ ## nm2(DAT + len * 6, LUT);                \
    fft_ ## nm1(DAT, LUT);                      \
}

/**T
\subsection{Small IFFTs}
Up to length $2^4$, we provide hard-coded inverse FFTs:
*/

static void ifft_0(__unused real * __restrict DAT,
    __unused const real * __restrict LUT)
{
    UNUSED(DAT);
    UNUSED(LUT);
    /* Do nothing */
}

static void ifft_1(real * __restrict DAT,
    __unused const real * __restrict LUT)
{
    UNUSED(LUT);
    FFT_PM(DAT, DAT + 2);
}

static void ifft_2(real * __restrict DAT,
    __unused const real * __restrict LUT)
{
    UNUSED(LUT);
    FFT_PM(DAT, DAT + 2);
    IFFT_SRM(DAT, DAT + 2, DAT + 4, DAT + 6);
}

static void ifft_3(real * __restrict DAT,
    __unused const real * __restrict LUT)
{
    UNUSED(LUT);
    FFT_PM(DAT, DAT + 2);
    IFFT_SRM(DAT, DAT + 2, DAT + 4, DAT + 6);
    FFT_PM(DAT + 8, DAT + 10);
    FFT_PM(DAT + 12, DAT + 14);
    IFFT_SRM(DAT, DAT + 4, DAT + 8, DAT + 12);
    IFFT_SRM_PI_4(DAT + 2, DAT + 6, DAT + 10, DAT + 14);
}

static void ifft_4(real * __restrict DAT,
    const real * __restrict LUT)
{

    FFT_PM(DAT, DAT + 2);
    IFFT_SRM(DAT, DAT + 2, DAT + 4, DAT + 6);
    FFT_PM(DAT + 8, DAT + 10);
    FFT_PM(DAT + 12, DAT + 14);
    IFFT_SRM(DAT, DAT + 4, DAT + 8, DAT + 12);
    IFFT_SRM_PI_4(DAT + 2, DAT + 6, DAT + 10, DAT + 14);
    FFT_PM(DAT + 16, DAT + 18);
    IFFT_SRM(DAT + 16, DAT + 18, DAT + 20, DAT + 22);
    FFT_PM(DAT + 24, DAT + 26);
    IFFT_SRM(DAT + 24, DAT + 26, DAT + 28, DAT + 30);
    IFFT_SRM(DAT, DAT + 8, DAT + 16, DAT + 24);
    IFFT_SRM_W(DAT + 2, DAT + 10, DAT + 18, DAT + 26, LUT + 10);
    IFFT_SRM_PI_4(DAT + 4, DAT + 12, DAT + 20, DAT + 28);
    IFFT_SRM_W(DAT + 6, DAT + 14, DAT + 22, DAT + 30, LUT + 14);
}

/**T
\subsection{Large IFFTs}
As with FFTs, we define a generic split-radix inverse FFT macro for sizes
$2^5$ up to $2^{29}$.
*/

#define IFFT_FUNC(n, nm1, nm2, len)                 \
static void ifft_ ## n(real * __restrict DAT,             \
    const real * __restrict LUT)                        \
{                                   \
    unsigned i;                         \
                                    \
    ifft_ ## nm1(DAT, LUT);                     \
    ifft_ ## nm2(DAT + len * 4, LUT);               \
    ifft_ ## nm2(DAT + len * 6, LUT);               \
                                    \
    IFFT_SRM(DAT, DAT + len * 2, DAT + len * 4, DAT + len * 6); \
    for (i = 2; i < 2 * len; i += 2)                \
        IFFT_SRM_W(DAT + i, DAT + len * 2 + i,          \
            DAT + len * 4 + i, DAT + len * 6 + i,       \
            LUT + len * 2 + i);                 \
}

/**T
\bibliographystyle{amsplain}
\begin{thebibliography}{X}

\bibitem{DJB99} D.J.~Bernstein, \textit{djbfft}, {\tt
http://cr.yp.to/djbfft.html}
\end{thebibliography}
*/

#define VOL *(volatile real *)&

#define R(a0,a1,b0,b1,wre,wim) { \
  t1 = a0 - a1; \
  t2 = b0 - b1; \
  t5 = t1 * wim; \
  t6 = t2 * wim; \
  t3 = VOL a0; \
  t1 *= wre; \
  t3 += a1; \
  t2 *= wre; \
  t1 -= t6; \
  t4 = VOL b0; \
  t2 += t5; \
  t4 += b1; \
  a0 = t3; \
  b1 = t2; \
  a1 = t4; \
  b0 = t1; \
  }

#define RHALF(a0,a1,b0,b1) { \
  t1 = a0 - a1; \
  t2 = b0 - b1; \
  t3 = a0 + a1; \
  t5 = t1 - t2; \
  t1 += t2; \
  t4 = VOL b0; \
  t5 *= sqrthalf; \
  t4 += b1; \
  t1 *= sqrthalf; \
  a0 = t3; \
  b1 = t1; \
  a1 = t4; \
  b0 = t5; \
  }

#define RZERO(a0,a1,b0,b1) { \
  t1 = a0 - a1; \
  t2 = b0 - b1; \
  t3 = a0 + a1; \
  t4 = b0 + b1; \
  b0 = t1; \
  a0 = t3; \
  b1 = t2; \
  a1 = t4; \
  }

#define V(a0,a1,b0,b1,wre,wim) { \
  t5 = b0 * wre; \
  t1 = b1 * wim; \
  t6 = b1 * wre; \
  t5 += t1; \
  t3 = b0 * wim; \
  t2 = a0 - t5; \
  t6 -= t3; \
  t5 += a0; \
  t4 = a1 - t6; \
  t6 += a1; \
  a1 = t2; \
  a0 = t5; \
  b1 = t4; \
  b0 = t6; \
  }

#define VHALF(a0,a1,b0,b1) { \
  t5 = b0 + b1; \
  t6 = b1 - b0; \
  t5 *= sqrthalf; \
  t2 = VOL a0; \
  t6 *= sqrthalf; \
  t2 -= t5; \
  t5 += a0; \
  t4 = a1 - t6; \
  t6 += a1; \
  a1 = t2; \
  a0 = t5; \
  b0 = t6; \
  b1 = t4; \
  }

#define VZERO(a0,a1,b0,b1) { \
  t1 = a0 + b0; \
  t2 = a0 - b0; \
  t3 = a1 + b1; \
  t4 = a1 - b1; \
  a0 = t1; \
  b0 = t3; \
  a1 = t2; \
  b1 = t4; \
  }

static void r2c_0(__unused real * __restrict DAT, __unused const real * __restrict w)
{
    UNUSED(DAT);
    UNUSED(w);
    /* Do nothing */
}

void r2c_1(real * __restrict a, __unused const real * __restrict w)
{
  register real t1, t2;

  UNUSED(w);

  t1 = a[0] + a[1];
  t2 = a[0] - a[1];
  a[0] = t1;
  a[1] = t2;
}

void r2c_2(real * __restrict a, __unused const real * __restrict w)
{
  register real t1, t2, t3, t4, t6;

  UNUSED(w);

  t3 = a[0] + a[1];
  t4 = a[2] + a[3];
  t1 = a[0] - a[1];
  t2 = a[2] - a[3];
  t6 = t3 - t4;
  t3 += t4;
  a[2] = t1;
  a[3] = t2;
  a[0] = t3;
  a[1] = t6;
}

void r2c_3(real * __restrict a, __unused const real * __restrict w)
{
  register double t1, t2, t3, t4, t5, t6, t7, t8;

  UNUSED(w);

  t2 = a[0] + a[1];
  t8 = a[4] + a[5];
  t3 = a[2] - a[3];
  t6 = t2 - t8;
  t2 += t8;
  t1 = a[2] + a[3];
  t7 = a[6] + a[7];
  a[2] = (real)t6;
  t5 = t1 - t7;
  t1 += t7;
  t4 = a[0] - a[1];
  a[3] = (real)t5;
  t8 = t2 - t1;
  t2 += t1;
  t7 = a[6] - a[7];
  a[1] = (real)t8;
  t6 = t3 - t7;
  t3 += t7;
  a[0] = (real)t2;
  t6 *= SQRTHALF;
  t8 = a[4] - a[5];
  t3 *= SQRTHALF;
  t1 = t4 - t6;
  t4 += t6;
  t2 = t8 - t3;
  t8 += t3;
  a[6] = (real)t1;
  a[4] = (real)t4;
  a[7] = (real)t2;
  a[5] = (real)t8;
}



void r2c_4(real * __restrict a, const real * __restrict w)
{
  register real t1, t2, t3, t4, t5, t6;

  RZERO(a[0],a[1],a[8],a[9]);
  R(a[2],a[3],a[10],a[11],w[10+0],w[10+1]);
  R(a[4],a[5],a[12],a[13],w[10+2],w[10+3]);
  R(a[6],a[7],a[14],a[15],w[10+4],w[10+5]);
  r2c_3(a, w);
  fft_2((a + 8), (real*)w);
}

/* a[0...8n-1], w[0...2n-1]; n even, n >= 4 */
void rpass(register real *a,register const real *w,register unsigned int n)
{
  register real t1, t2, t3, t4, t5, t6;
  register real *b;
  register unsigned int k;

  b = a + 4 * n;
  k = n - 2;

  RZERO(a[0],a[1],b[0],b[1]);
  R(a[2],a[3],b[2],b[3],w[0],w[1]);
  R(a[4],a[5],b[4],b[5],w[2],w[3]);
  R(a[6],a[7],b[6],b[7],w[4],w[5]);

  for (;;) {
    R(a[8],a[9],b[8],b[9],    w[6] ,w[7] );
    R(a[10],a[11],b[10],b[11],w[8] ,w[9] );
    R(a[12],a[13],b[12],b[13],w[10],w[11]);
    R(a[14],a[15],b[14],b[15],w[12],w[13]);
    if (!(k -= 2)) break;
    a += 8;
    b += 8;
    w += 4*2;
  }
}


#define R2CFFT_FUNC(n, nm1, nm2, len)                 \
static void r2c_ ## n(real * __restrict a, const real * __restrict w) \
{                                   \
  rpass(a,w+2+(1<<nm1),1<<(nm2-1));   \
  r2c_ ## nm1(a,w);                \
  fft_  ## nm2(a + (1<<nm1),w);     \
}




static void c2r_0(__unused real * __restrict DAT, __unused const real * __restrict w)
{
    UNUSED(DAT);
    UNUSED(w);
    /* Do nothing */
}
void c2r_1(real * __restrict a, __unused const real * __restrict w)
{
  register real t1, t2;
  
  UNUSED(w);

  t1 = a[0] + a[1];
  t2 = a[0] - a[1];
  a[0] = t1;
  a[1] = t2;
}
void c2r_2(real * __restrict a, __unused const real * __restrict w)
{
  register real t1, t3, t5, t6;

  UNUSED(w);

  t5 = a[0] + a[1];
  t6 = a[0] - a[1];
  t1 = t5 + a[2];
  t5 -= a[2];
  t3 = t6 + a[3];
  t6 -= a[3];
  a[0] = t1;
  a[1] = t5;
  a[2] = t3;
  a[3] = t6;
}
void c2r_3(real * __restrict a, __unused const real * __restrict w)
{
  register double t1, t2, t3, t4, t5, t6, t7, t8;
  
  UNUSED(w);

  t5 = a[0] + a[1];
  t2 = a[4] + a[6];
  t8 = t5 + a[2];
  t5 -= a[2];
  t1 = a[0] - a[1];
  t7 = t8 + t2;
  t8 -= t2;
  t3 = a[4] - a[6];
  a[0] = (real)t7;
  t6 = a[5] + a[7];
  a[1] = (real)t8;
  t7 = t5 + t6;
  t5 -= t6;
  t4 = a[5] - a[7];
  a[4] = (real)t7;
  t6 = t4 - t3;
  t3 += t4;
  a[5] = (real)t5;
  t3 *= SQRTHALF;
  t2 = t1 + a[3];
  t1 -= a[3];
  t6 *= SQRTHALF;
  t7 = t2 - t3;
  t3 += t2;
  t8 = t1 - t6;
  t6 += t1;
  a[3] = (real)t7;
  a[7] = (real)t8;
  a[2] = (real)t3;
  a[6] = (real)t6;
}
/* a[0...8n-1], w[0...2n-1]; n even, n >= 4 */
void vpass(register real *a,register const real *w,register unsigned int n)
{
  register real t1, t2, t3, t4, t5, t6;
  register real *b;
  register unsigned int k;

  b = a + 4 * n;
  k = n - 2;

  VZERO(a[0],a[1],b[0],b[1]);
  V(a[2],a[3],b[2],b[3],w[0*2+0],w[0*2+1]);
  V(a[4],a[5],b[4],b[5],w[1*2+0],w[1*2+1]);
  V(a[6],a[7],b[6],b[7],w[2*2+0],w[2*2+1]);

  for (;;) {
    V(a[8],a[9],b[8],b[9],w[3*2+0],w[3*2+1]);
    V(a[10],a[11],b[10],b[11],w[4*2+0],w[4*2+1]);
    V(a[12],a[13],b[12],b[13],w[5*2+0],w[5*2+1]);
    V(a[14],a[15],b[14],b[15],w[6*2+0],w[6*2+1]);
    if (!(k -= 2)) break;
    a += 8;
    b += 8;
    w += 4*2;
  }
}
void c2r_4(real * __restrict a, __unused const real * __restrict w)
{
  register real t1, t2, t3, t4, t5, t6;

  ifft_2(a + 8, (real*)w);
  c2r_3(a, w);
  VZERO(a[0],a[1],a[8],a[9]);
  V(a[2],a[3],a[10],a[11],w[10+0],w[10+1]);
  V(a[4],a[5],a[12],a[13],w[10+2],w[10+3]);
  V(a[6],a[7],a[14],a[15],w[10+4],w[10+5]);
}

#define C2RFFT_FUNC(n, nm1, nm2, len)   \
static void c2r_ ## n(real * __restrict a, const real * __restrict w)  \
{                                       \
  ifft_  ## nm2 (a + (1<<nm1), w);      \
  c2r_ ## nm1 (a, w);                 \
  vpass(a,w + 2+(1<<nm1), 1<<(nm2-1));    \
}

#define DEFINE_FUNCS(X) \
X(5, 4, 3, 8)           \
X(6, 5, 4, 16)          \
X(7, 6, 5, 32)          \
X(8, 7, 6, 64)          \
X(9, 8, 7, 128)         \
X(10, 9, 8, 256)        \
X(11, 10, 9, 512)       \
X(12, 11, 10, 1024)     \
X(13, 12, 11, 2048)     \
X(14, 13, 12, 4096)     \
X(15, 14, 13, 8192)     \
X(16, 15, 14, 16384)    \
X(17, 16, 15, 32768)    \
X(18, 17, 16, 65536)    \
X(19, 18, 17, 131072)   \
X(20, 19, 18, 262144)   \
X(21, 20, 19, 524288)   \
X(22, 21, 20, 1048576)  \
X(23, 22, 21, 2097152)  \
X(24, 23, 22, 4194304)  \
X(25, 24, 23, 8388608)  \
X(26, 25, 24, 16777216) \
X(27, 26, 25, 33554432) 
//X(28, 27, 26, 67108864) 
//X(29, 28, 27, 134217728)

#define DEFINE_API(X) \
static void (* X ## _list[])(real * __restrict, const real * __restrict) = {        \
    X ## _0, X ## _1, X ## _2,  X ## _3,  X ## _4,  X ## _5,  X ## _6,  X ## _7,    \
    X ## _8, X ## _9, X ## _10, X ## _11, X ## _12, X ## _13, X ## _14, X ## _15,   \
    X ## _16, X ## _17, X ## _18, X ## _19, X ## _20, X ## _21, X ## _22, X ## _23, \
    X ## _24, X ## _25, X ## _26, X ## _27                                          \
};                                                                                  \
void tricl_fft_ ## X(real * __restrict DAT, int size, const real * __restrict LUT)  \
{                                                                                   \
    assert(0 <= size && size <= (int)(sizeof(X ## _list) / sizeof(X ## _list[0]))); \
    X ## _list[size](DAT, LUT);                                                     \
}

DEFINE_FUNCS(FFT_FUNC)
DEFINE_FUNCS(IFFT_FUNC)
DEFINE_FUNCS(R2CFFT_FUNC)
DEFINE_FUNCS(C2RFFT_FUNC)

#if defined _MSC_VER && _MSC_VER >= 1500
// warning C6385: Invalid data: accessing 'fft_list', the readable size is '112' bytes, but '-8' bytes might be read
#pragma warning (disable: 6385) 
#endif

DEFINE_API(fft)
DEFINE_API(ifft)
DEFINE_API(c2r)
DEFINE_API(r2c)


unsigned int fftfreq_c(unsigned int i,unsigned int n)
{
  unsigned int m;

  if (n <= 2) return i;

  m = n >> 1;
  if (i < m) return fftfreq_c(i,m) << 1;

  i -= m;
  m >>= 1;
  if (i < m) return (fftfreq_c(i,m) << 2) + 1;
  i -= m;
  return ((fftfreq_c(i,m) << 2) - 1) & (n - 1);
}

static void doit(unsigned int *f,unsigned int n,unsigned int scale,unsigned int offset)
{
  if (n <= 1) {
    f[0] = offset;
    return;
  }
  if (n == 2) {
    f[0] = offset;
    f[1] = scale + offset;
    return;
  }
  n >>= 1;
  doit(f,n,scale << 1,offset);

  f += n;
  n >>= 1;
  doit(f,n,scale << 2,offset + scale);
  doit(f + n,n,scale << 2,offset - scale);

}

void fftfreq_ctable(unsigned int *f,unsigned int n)
{
  unsigned int i;

  doit(f,n,1,0);
  for (i = 0;i < n;++i)
    f[i] &= n - 1;
}

unsigned int fftfreq_r(unsigned int i,unsigned int n)
{
  unsigned int m;

  if (n <= 2) return i;

  m = n >> 1;
  if (i < m) return fftfreq_r(i,m) << 1;

  i -= m;
  i >>= 1;
  m >>= 1;
  return (fftfreq_c(i,m) << 2) + 1;
}

void fftfreq_rtable(unsigned int *f,unsigned int n)
{
  unsigned int i;

  for (i = 0;i < n;++i)
    f[i] = fftfreq_r(i,n);
}



// ASP: add real convolution helpers

void tricl_fft_r2c_scale(real * DAT, int n)
{
    double s;
    int i;

    assert(1 <= n && n <= 29);

    s = ldexp(1.0, -(n-1));
    for (i = 0; i < 1 << n; i++)
        DAT[i] = (real)(DAT[i] * s);

    DAT[0] *= 0.5;  // DC
    DAT[1] *= 0.5;  // Nyquist
}
real * tricl_fft_r2c_preproc(const real * dat, int logn, real * out)
{
    int i, n = 1 << logn;
    real * p = (out == dat || !out) ? malloc(n*sizeof(real)) : out;
    if (p && out)
    {
        for (i = 0; i < n/2; i++)
        {
            p[i*2]   = dat[i];
            p[i*2+1] = dat[i + n/2];
        }
        if (out == dat) {memcpy(out, p, n*sizeof(real)); free(p); p = out;}
    }
    return p;
}

real * tricl_fft_c2r_postproc(const real * dat, int logn, real * out)
{
    int i, n = 1 << logn;
    real * p = (out == dat || !out) ? malloc(n*sizeof(real)) : out;
    if (p && out)
    {
        for (i = 0; i < n/2; i++)
        {
            p[i      ] = dat[i*2  ];
            p[i + n/2] = dat[i*2+1];
        }
        if (out == dat) {memcpy(out, p, n*sizeof(real)); free(p); p = out;}
    }
    return p;
}

//////////////////////// 
#define TRICL_2DFFT_VIA_REAL_FFT 1


/**
    Index reordering for row[0] & row[N] of 2D FFT

    reordering given by the following code:

    int * reord = malloc(sizeof(int)*(1<<glogx));
    fftfreq_ctable(reord, (1<<glogx));
    PERM_invertBingChaoHuang(reord, (1<<glogx));
    for (c = 1; c < (1<<(logx-1)); c++)
    {
        int i = reord[c];
        int k = reord[(1<<(logx))  - c];
        sumdiff(i,k)
    ----

    this simplified to:
    k = bitperm(i, logx)

*/
static unsigned bitperm(unsigned x, unsigned nbits)
{
    unsigned y = x >> 1;
    unsigned s = x ^ y;
    unsigned m = 1 << nbits;
    unsigned flag = 0;
    for (; m >= (y&-(int)y) && m; m>>=1)
    {
        if (!flag)  
        {   
            if (x&m&y) flag= 1;
        } 
        else 
        { 
            if (m&y) s ^= m; flag = 0;
        }
    }
    return s;
}


/*
*   2D fft transform of real array WxH array
*   Transform size is (1<<logx)x(1<<logy)
*   Output size is (1<<logx)x((1<<logy/2)+1) complex values
*
*   Output have implicit vertical symmetry 
*
*/
void tricl_fft2d(real * out, const real * inp, int logx, int logy, int w, int h,  const real * twid)
{
    int r,c,i;
    int stride = (1 << logx);
    real * scratch = calloc(2*sizeof(real), ((size_t)1<<logy));
    if (!scratch)
    {
        return;
    }

    memset(out, 0, 2*sizeof(real)*((size_t)1<<logx)*(size_t)((1ul<<(logy))));

    // Transform columns
    // w transforms with (1<<logy) size each
    for (c = 0; c < w; c++)
    {
        memset(scratch, 0, (1 << logy)*2*sizeof(real));
#if TRICL_2DFFT_VIA_REAL_FFT
        for (i = 0; i < h; i++) scratch[i] = inp[c + i*w];  // col => row
        tricl_fft_r2c_preproc(scratch, logy, scratch);      // real-to-complex FFT
        tricl_fft_r2c(scratch, logy, twid);
        for (r = 0; r < (1 << (logy-1)); r++)               // complex row => colum
        {
            i = c + r * stride;
            out[2*i+0] = scratch[2*r+0];
            out[2*i+1] = scratch[2*r+1];
        }
#else
        for (r = 0; r < h; r++)
        {
            scratch[2*r+0] = inp[c+r*w];
        }
        tricl_fft_fft(scratch, logy, twid);
        for (r = 0; r < (1 << logy); r++)
        {
            i = c + r * stride;
            out[2*i+0] = scratch[2*r+0];
            out[2*i+1] = scratch[2*r+1];
        }
#endif
    }

    // Transform rows
#if TRICL_2DFFT_VIA_REAL_FFT
    for (r = 0; r < (1<<(logy-1)); r++)
#else
    for (r = 0; r < (1<<(logy)); r++)
#endif
    {
        tricl_fft_fft(out + r*stride*2, logx, twid);
    }

#if TRICL_2DFFT_VIA_REAL_FFT
    // 1st row contains FFT of two real sequences 
    // FFT(H[0] + j*H[n])
    // Split it to two FFT
    for (i = 1; i < (1<<(logx)); i++)
    {
        real re0, re1, im0, im1;
        int k = bitperm(i, logx);
        if (k >= i) continue;

        re0 =  out[2*i];
        re1 =  out[2*k];
        im0 =  out[2*i+1];
        im1 =  out[2*k+1];
        out[2*i]   = (re0 + re1)*0.5f;
        out[2*k]   = (im0 + im1)*0.5f;
        out[2*i+1] = (im0 - im1)*0.5f;
        out[2*k+1] = (re0 - re1)*0.5f;
    }
#endif
    free(scratch);
}


void tricl_ifft2d(real * out, real * inp, int logx, int logy, int w, int h, const real * twid)
{
    double scale = ldexp(1.0, -(logy+logx));

    int r,c,i;
    int stride = (1 << logx);
    real * scratch = malloc(2*sizeof(real)*((size_t)1<<logy));
    if (!scratch)
    {
        return;
    }

#if TRICL_2DFFT_VIA_REAL_FFT
    for (i = 1; i < (1<<logx); i++)
    {
        real re0, re1, im0, im1;
        int k = bitperm(i, logx);
        if (k >= i) continue;

        re0 =  inp[2*i];
        re1 =  inp[2*k];
        im0 =  inp[2*i+1];
        im1 =  inp[2*k+1];
        inp[2*i]   = (re0 + im1);
        inp[2*k]   = (re0 - im1);
        inp[2*i+1] = (re1 + im0);
        inp[2*k+1] = (re1 - im0);
    }
#endif
       
#if TRICL_2DFFT_VIA_REAL_FFT
    for (r = 0; r < (1<<(logy-1)); r++)
#else
    for (r = 0; r < (1<<(logy)); r++)
#endif
    {
        tricl_fft_ifft(inp + r*stride*2, logx, twid);
    }
    for (c = 0; c < w; c++)
    {
        memset(scratch, 0, (1 << logy)*2*sizeof(real));

#if TRICL_2DFFT_VIA_REAL_FFT
        inp[c*2+0] *= 0.5;
        inp[c*2+1] *= 0.5;
        for (r = 0; r < (1 << (logy-1)); r++)
        {
            i = c + r * stride;
            scratch[2*r+0] = inp[2*i];
            scratch[2*r+1] = inp[2*i+1];
        }
        tricl_fft_c2r(scratch, logy, twid);
        tricl_fft_c2r_postproc(scratch, logy, scratch);
        for (i = 0; i < h; i++)
        {
            out[c+i*w] = (real)(scratch[i]*2*scale);
        }
#else
        for (r = 0; r < (1 << (logy)); r++)
        {
            i = c + r * stride;
            scratch[2*r+0] = inp[2*i];
            scratch[2*r+1] = inp[2*i+1];
        }
        tricl_fft_ifft(scratch, logy, twid);
        for (r = 0; r < h; r++)
        {
            out[c+r*w] = scratch[2*r]*scale;
        }
#endif
    }
    free(scratch);
}


void tricl_fft2dconv_mulpw(real * __restrict DAT1, real * __restrict DAT2, int n)
{
    real xr, xi;
    int i;
#if TRICL_2DFFT_VIA_REAL_FFT
    if (n >= 4) 
    for (i = 0; i < 4; i++) {
        DAT1[i] *= DAT2[i];
    }
    for (i = 2; i < n/2; i++) 
#else
    for (i = 0; i < n; i++) 
#endif
    {
        xr = DAT1[i * 2];
        xi = DAT1[i * 2 + 1];
        
        DAT1[i * 2] = xr * DAT2[i * 2] - xi * DAT2[i * 2 + 1];
        DAT1[i * 2 + 1] = xr * DAT2[i * 2 + 1] + xi * DAT2[i * 2];
    }
}





#ifdef dsp_ffttricl_test
/******************************************************************************
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!                                                                       !!!!
!!!!                 !!!!!!!!  !!!!!!!!   !!!!!!!   !!!!!!!!               !!!!
!!!!                    !!     !!        !!            !!                  !!!!
!!!!                    !!     !!        !!            !!                  !!!!
!!!!                    !!     !!!!!!     !!!!!!!      !!                  !!!!
!!!!                    !!     !!               !!     !!                  !!!!
!!!!                    !!     !!               !!     !!                  !!!!
!!!!                    !!     !!!!!!!!   !!!!!!!      !!                  !!!!
!!!!                                                                       !!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
******************************************************************************/

#include <math.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#define PI 3.14159265358979323846
#define SQR( x ) ( (x) *(x) )

static void FFT_slow(
    const real * xre, const real * xim, int xstep,
    real * yre, real * yim, int ystep,
    int n, int dir
    )
{
    const double ph0 = dir*2.0*PI/n;
    int w, k;
    for (w = 0; w < n; w++)
    {
        double sum_re = 0, sum_im = 0;
        for (k = 0; k < n; k++)
        {
            double s = sin(ph0*k*w);
            double c = cos(ph0*k*w);
            sum_re += xre[k*xstep] * c - xim[k*xstep] * s;
            sum_im += xre[k*xstep] * s + xim[k*xstep] * c;
        }
        yre[w*ystep] = (real)(sum_re);
        yim[w*ystep] = (real)(sum_im);
    }
}


static void vec_rand(real * x, int xStep, int N)
{
    int i;
    for (i = 0; i < N; i++)
    {
        *x = ((real)rand() / RAND_MAX)*2 - 1;
        x += xStep;
    }
}

static void vec_snr(real * x, int xstep, const real * y, int ystep, int n)
{
    double signl = 0;
    double noise = 0;
    int i;
    for (i = 0; i < n; i++)
    {
        signl += (*x)*(*x);
        noise += (*x - *y)*(*x - *y);
        x += xstep; 
        y += ystep;
    }
    printf(noise?" %.3f dB":" MATCH ", 10 * log10(signl/noise));
}




// Test session parameter:

#define LOGN 4                  // Log (FFT size)
#define MAXN (1<<LOGN)          // FFT size
real       g_lut[MAXN*4];       // Run-time generated twiddle factors
unsigned int g_permc[MAXN*2];   // Run-time generated permutation for complex FFT frequency domain
unsigned int g_permr[MAXN*2];   // Run-time generated permutation for real FFT frequency domain


/**
*   Verify IFFT(FFT(x)) == x
*/
static void test_identity(int logN)
{
    int N = 1<<logN;
    real *r = malloc(2*N*sizeof(real));
    real *x = malloc(2*N*sizeof(real));
    real *y = malloc(2*N*sizeof(real));
    int test;
    for (test = 0; test < 4; test++)
    {
        vec_rand(r, 1, 2*N);
        memcpy(x, r, 2*N*sizeof(real));

        switch(test)
        {
        case 0:
            printf("\nTesting complex tricl FFT identity");
            // Scale after IFFT
            tricl_fft_fft(x,logN,g_lut);
            tricl_fft_ifft(x,logN,g_lut);
            tricl_fftconv_scale(x,logN);
            break;
        case 1:
            printf("\nTesting real tricl FFT identity");
            // Scale after IFFT
            // However, frequency domain scaling also required
            tricl_fft_r2c(x,logN,g_lut);
            x[0]*=.5; x[1]*=.5;
            tricl_fft_c2r(x,logN,g_lut);
            tricl_fftconv_scale(x,logN-1); 
            break;
        case 2:
            printf("\nTesting real tricl FFT identity");
            // Scale after FFT in frequency domain
            tricl_fft_r2c(x,logN,g_lut);
            tricl_fft_r2c_scale(x,logN);
            tricl_fft_c2r(x,logN,g_lut);
            break;
        case 3:
            printf("\nTesting real tricl FFT with permutation identity");
            // Scale after FFT in frequency domain
            tricl_fft_r2c_preproc(x, logN, x);
            tricl_fft_r2c(x,logN,g_lut);
            tricl_fft_r2c_scale(x,logN);
            tricl_fft_c2r(x,logN,g_lut);
            tricl_fft_c2r_postproc(x, logN, x);
            break;
        }

        vec_snr(r, 1, x, 1, 2*N);
    }
    free(r); free(x); free(y);
}

/**
*   Verify FFT(x) == ReferenceFFT(x)
*/
static void compare_with_tricl(int logN)
{
    int test,i,N = 1<<logN;
    real *x0 = calloc(2*N,sizeof(real));
    real *y0 = calloc(2*N,sizeof(real));
    real *x1 = calloc(2*N,sizeof(real));
    real *y1 = calloc(2*N,sizeof(real));
#define REF_FFT FFT_slow

    for (test = 0; test < 4; test++)
    {
        memset(x0,0,2*N*sizeof(real));
        memset(x1,0,2*N*sizeof(real));
        memset(y0,0,2*N*sizeof(real));
        memset(y1,0,2*N*sizeof(real));


        x0[2] = 1;
        vec_rand(x0, 1, 2*N);
        memcpy(x1, x0, 2*N*sizeof(real));
        switch(test)
        {
        case 0:
            printf("\nTesting complex FFT vs reference");
            REF_FFT(x0,x0+1,2, y0,y0+1,2, N, 1);
            tricl_fft_fft(x1, logN, g_lut);
            for (i = 0; i < N; i++)
            {
                y1[2*g_permc[i]]   = x1[2*i];
                y1[2*g_permc[i]+1] = x1[2*i+1];
            }
            break;
        case 1:
            printf("\nTesting complex IFFT vs reference");
            REF_FFT(x0,x0+1,2, y0,y0+1,2, N, -1);
            for (i = 0; i < N; i++)
            {
                y1[2*i]   = x1[2*g_permc[i]];
                y1[2*i+1] = x1[2*g_permc[i]+1];
            }
            tricl_fft_ifft(y1, logN, g_lut);
            break;
        case 2:
            printf("\nTesting real FFT vs reference");
            for (i = 0; i < N; i++) 
            {
                x0[2*i+1] = 0;      // clear imaginary part for reference complex FFT
                x1[i] = x1[2*i];    // pack real input for tricl_fft
            } 

            REF_FFT(x0,x0+1,2, y0,y0+1,2, N, 1);

            tricl_fft_r2c_preproc(x1, logN, x1);
            tricl_fft_r2c(x1, logN, g_lut);

            // Permutation from tricl to conventional order:
            // Re(DC), Re(Nyquist), Re(f1), Im(f1) ....  Re(Nyquist-1), Im(Nyquist-1)
            y1[0] = x1[0];  // DC
            y1[1] = x1[1];  // Nyquist
            for (i = 2; i < N; i += 2)
            {
                int j = g_permr[i];
                if (j >= N/2)
                {
                    // Big permutation index indicates conjugate
                    j = N-j;
                    x1[i+1] *= -1;
                }
                y1[2*j] = x1[i];
                y1[2*j+1] = x1[i+1];
            }

            // Permutation from conventional to natural order (full spectrum)
            y1[0] = y1[0]; 
            y1[N] = y1[1]; 
            y1[1] = 0;
            y1[N+1] = 0;
            for (i = 2; i < N; i += 2)
            {
                y1[2*N-i] = y1[i];
                y1[2*N-i+1] = -y1[i+1];
            }
            break;

        case 3:
            printf("\nTesting real IFFT vs reference");


            // Conjugate lower half of the spectrum to upper half 
            for (i = 2; i < N; i += 2)
            {
                x1[2*N-i]   =  x1[i];
                x1[2*N-i+1] = -x1[i+1];
            }
            x1[1] = 0;
            x1[N+1] = 0;
            memcpy(x0, x1, 2*N*sizeof(real));

            REF_FFT(x0,x0+1,2, y0,y0+1,2, N, -1);


            for (i = 2; i < N; i += 2)
            {
                int j = g_permr[i];
                if (j >= N/2)
                {
                    // Big permutation index indicates conjugate
                    // May ignore it, because full spectrum available for this test

                    // not necessary, when processing full spectrum
                    //j = N-j;
                    //x1[2*j+1] *= -1;
                }
                y1[i] = 2*x1[2*j];
                y1[i+1] = 2*x1[2*j+1];
            }
            y1[0] = x1[0];
            y1[1] = x1[N];

            tricl_fft_c2r(y1, logN, g_lut);
            tricl_fft_c2r_postproc(y1, logN, y1);

            for (i = N-1; i >= 0; i--)
            {
                y1[2*i] = y1[i];
                y1[2*i+1] = 0;
            }
            break;
        }

        vec_snr(y0, 1, y1, 1, 2*N);
    }
    free(x0); free(y0); free(x1); free(y1);
}


int main(int argc, char* argv[])
{
    tricl_fft_makelut(g_lut, LOGN);   //for fft-2048 max
    fftfreq_ctable(g_permc, MAXN);
    fftfreq_rtable(g_permr, MAXN);

    test_identity(LOGN);

    compare_with_tricl(LOGN);

    {
        int logx = LOGN;
        int logy = LOGN;
        int N = 1 << (logx + logy);
        int w = 1 << logx;
        int h = 1 << logy;
        real *x0 = calloc(w*h,2*sizeof(real));
        real *y0 = calloc(w*h,2*sizeof(real));
        real *x1 = calloc(w*h,2*sizeof(real));
        vec_rand(x0, 1, w*h);

        tricl_fft2d (y0, x0, logx, logy, w, h, g_lut);
        tricl_ifft2d(x1, y0, logx, logy, w, h, g_lut);

        printf("\nTesting 2D FFT identity");
        vec_snr(x0, 1, x1, 1, w*h);
    }
    return 0;
}

// dmc dsp_ffttricl.c -Ddsp_ffttricl_test && dsp_ffttricl.exe && del *.obj *.map dsp_ffttricl.exe

#endif //dsp_ffttricl_test
